# 庚子鼠年 戊寅月 丙戌日

## 描述

> 数据库引擎的了解，Mybatis多表查询
>
> 技术总结：[https://blog.csdn.net/qq_40674583/article/details/104303340](https://blog.csdn.net/qq_40674583/article/details/104303340)

## 随笔

### MySQL 引擎

#### 1.InnoDB存储引擎 

> 1. InnoDB给MySQL的表提供了事**务处理、回滚、崩溃修复能力**和多版本并发控制的事务安全。
> 2. InnoDB存储引擎总支持AUTO_INCREMENT。自动增长列的值不能为空，并且值必须唯一。MySQL中规定自增列必须为主键。
> 3. InnoDB还支持外键（FOREIGN KEY）。当删除、更新父表中的某条信息时，子表也必须有相应的改变，这是数据库的参照完整性规则。
> 4. nnoDB中，创建的表的表结构存储在.frm文件中（我觉得是frame的缩写吧）。数据和索引存储在innodb_data_home_dir和innodb_data_file_path定义的表空间中。
> 5.  **InnoDB的优势在于提供了良好的事务处理、崩溃修复能力和并发控制。缺点是读写效率较差，占用的数据空间相对较大**



**InnoDB：在mysql5.6版本以上被作为默认引擎，并且加入了行及锁定与外键约束。**

所以以下是使用InnoDB最好的选择：

> 1.更新密集的表。InnoDB存储引擎特别适合处理多重并发的更新请求。
> 2.事务。InnoDB存储引擎是支持事务的标准MySQL存储引擎。
> 3.自动灾难恢复。与其它存储引擎不同，InnoDB表能够自动从灾难中恢复。
> 4.外键约束。MySQL支持外键的存储引擎只有InnoDB。
> 5.支持自动增加列AUTO_INCREMENT属性。





#### 2.MyISAM存储引擎

> 1. MyISAM是MySQL中常见的存储引擎，曾经是MySQL的默认存储引擎。MyISAM是基于ISAM引擎发展起来的，增加了许多有用的扩展。
> 2. MyISAM的表存储成3个文件。文件的名字与表名相同。拓展名为frm、MYD、MYI。其实，frm文件存储表的结构；MYD文件存储数据，是MYData的缩写；MYI文件存储索引，是MYIndex的缩写。
> 3. 基于MyISAM存储引擎的表支持3种不同的存储格式。包括静态型、动态型和压缩型。其中，静态型是MyISAM的默认存储格式，它的字段是固定长度的；动态型包含变长字段，记录的长度不是固定的；压缩型需要用到myisampack工具，占用的磁盘空间较小。
> 4. MyISAM的优势在于占用空间小，处理速度快。缺点是不支持事务的完整性和并发性。



**MyISAM：在创建MyISAM的时候会出来三个默认的文件**

> 1.tb_demo.frm，存储表定义；
> 2.tb_demo.MYD，存储数据；
> 3.tb_demo.MYI，存储索引。
>
> 因为MyISAM表有无法处理事务，所以它只适合在一下几种情况下使用
>
> 1.选择密集型的表。MyISAM存储引擎在筛选大量数据时非常迅速，这是它最突出的优点。
> 2.插入密集型的表。MyISAM的并发插入特性允许同时选择和插入数据。例如：MyISAM存储引擎很适合管理邮件或Web服务器日志数据。





#### 3.MEMORY存储引擎

> 1. MEMORY是MySQL中一类特殊的存储引擎。它使用存储在内存中的内容来创建表，而且数据全部放在内存中。这些特性与前面的两个很不同。
> 2. 每个基于MEMORY存储引擎的表实际对应一个磁盘文件。该文件的文件名与表名相同，类型为frm类型。该文件中只存储表的结构。而其数据文件，都是存储在内存中，这样有利于数据的快速处理，提高整个表的效率。值得注意的是，服务器需要有足够的内存来维持MEMORY存储引擎的表的使用。如果不需要了，可以释放内存，甚至删除不需要的表。
> 3. MEMORY默认使用哈希索引。速度比使用B型树索引快。当然如果你想用B型树索引，可以在创建索引时指定。
> 4. 注意，MEMORY用到的很少，因为它是把数据存到内存中，如果内存出现异常就会影响数据。如果重启或者关机，所有数据都会消失。因此，基于MEMORY的表的生命周期很短，一般是一次性的。



**MEMORY：使用MEMORY引擎主要是因为速度，好处就在MEMORY采用的逻辑存储是系统内存,极大的提高了储存数据表的性能；**

**坏处就是当mysqld守护进程崩溃时，所有的Memory数据都会丢失。**

要求存储在Memory数据表里的数据使用的是长度不变的格式，这意味着不能使用BLOB和TEXT这样的长度可变的数据类型

所以一般在以下几种情况下使用Memory存储引擎：

> 1.目标数据较小，而且被非常频繁地访问。在内存中存放数据，所以会造成内存的使用，可以通过参数max_heap_table_size控制Memory表的大小，设置此参数，就可以限制Memory表的最大大小。
>
> 2.如果数据是临时的，而且必须立即使用，那么就可以存放在内存表中。
>
> 3.存储在Memory表中的数据如果突然丢失，不会对应用服务产生实质的负面影响。
>
> Memory同时支持散列索引和B树索引。B树索引的优于散列索引的是，可以使用部分查询和通配查询，也可以使用<、>和>=等操作符方便数据挖掘。散列索引进行“相等比较”非常快，但是对“范围比较”的速度就慢多了，因此散列索引值适合使用在=和<>的操作符中，不适合在<或>操作符中，也同样不适合用在order by子句中





四：

**MERGE：MERGE存储引擎是一组MyISAM表的组合，这些MyISAM表结构必须完全相同，所以就相当于一个集合器**。比起其他储存引擎MERGE不是很优秀，但是在某些情况下MERGE还是非常的有用。对于服务器日志这种信息，一般常用的存储策略是将数据分成很多表，每个名称与特定的时间端相关。

五：

ARCHIVE：

**Archive是归档的意思，在归档之后很多的高级功能就不再支持了，仅仅支持最基本的插入和查询两种功能。**在MySQL 5.5版以前，Archive是不支持索引，但是在MySQL 5.5以后的版本就开始支持索引了。Archive拥有很好的压缩机制，它使用zlib压缩库，在记录被请求时会实时压缩，所以它经常被用来当做仓库使用。





**参考博客：[https://blog.csdn.net/qq_41118581/article/details/90173117](https://blog.csdn.net/qq_41118581/article/details/90173117)**

**参考博客：[https://www.cnblogs.com/huangting/p/10883754.html](https://www.cnblogs.com/huangting/p/10883754.html)**

### InnoDB底层原理

> 1.页介绍
> 页是InnoDB存储引擎管理数据库的最小磁盘单位。页类型为B-Tree node的页，存放的即是表中行的实际数据了。
> InnoDB中的页大小为16KB，且不可以更改
> InnoDB可以将一条记录中的某些数据存储在真正的数据页面之外，即作为行溢出数据。MySQL的varchar数据类型可以存放65535个字节，但实际只能存储65532个。同时InnoDB是B+树结构的，因此每个页中至少应该有两个行记录，否则失去了B+树的意义，变成了链表，所以一行记录最大长度的阈值是8098，如果大于这个值就会将其存到溢出行中。
>
> ————————————————
> 版权声明：本文为CSDN博主「shancoder」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
> 原文链接：https://blog.csdn.net/u012978884/article/details/52416997

果然学习算法，打好基础才是王道

算法真香，学一个框架就是去记一些配置文件，熟练使用而已，成本低，不知道实现原理



### 索引

索引用于快速找出在某个列中有一特定值的行，不使用索引，MySQL必须从第一条记录开始读完整个表，直到找出相关的行，表越大，查询数据所花费的时间就越多，如果表中查询的列有一个索引，MySQL能够快速到达一个位置去搜索数据文件，而不必查看所有数据，那么将会节省很大一部分时间。

**参考博客：https://www.jianshu.com/p/0d6c828d3c70**





### 多表查询

### 动态SQL

### 一级缓存

- 在同一个回话中有效
- 使用插入，删除，更新操作会刷新缓存

### 二级缓存

1.开启全局缓存

2.在mapper中使用缓存

方法上开启



- 当一级缓存回话提交，或者关闭的时候，会提交到二级缓存中
- 开启二级缓存，在同一个Mapper中有效
- 所有的数据都会先放在一级缓存中



### 查询

> 1.先看二级缓存中有没有
>
> 2.再再看二级缓存中有没有
>
> 3.去数据库查询



### Redis 实现二级缓存



