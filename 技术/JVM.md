# JVM总结

## 1.JVM的生命周期

**JVM实例对应了一个独立运行的java程序它是进程级别**

​    a)  启动。启动一个Java程序时，一个JVM实例就产生了，任何一个拥有public static void main(String[] args)函数的class都可以作为JVM实例运行的起点

​    b)  运行。main()作为该程序初始线程的起点，任何其他线程均由该线程启动。JVM内部有两种线程：守护线程和非守护线程，**main()属于非守护线程**，**守护线程通常由JVM自己使用**，java程序也可以标明自己创建的线程是守护线程

​    c)  消亡。**当程序中的所有非守护线程都终止时**，JVM才退出；若安全管理器允许，程序也可以使用Runtime类或者System.exit()来退出

**JVM执行引擎实例则对应了属于用户运行程序的线程它是线程级别的**



## 2. JVM的体系结构

​    a)  类装载器（ClassLoader）（用来装载.class文件）

​    b)  执行引擎（执行字节码，或者执行本地方法）

​    c)  运行时数据区（方法区、堆、java栈、PC寄存器、本地方法栈）



## 3.类加载器

**1.**  **装载**

​    装载过程负责找到二进制字节码并加载至JVM中，JVM通过类名、类所在的包名通过ClassLoader来完成类的加载，同样，也采用以上三个元素来标识一个被加载了的类：类名+

包名+ClassLoader实例ID。

**2.**  **链接**

​    链接过程负责对二进制字节码的格式进行校验、初始化装载类中的静态变量以及解析类中调用的接口、类。

完成校验后，JVM初始化类中的静态变量，并将其值赋为默认值。

最后对类中的所有属性、方法进行验证，以确保其需要调用的属性、方法存在，以及具备应的权限（例如public、private域权限等），会造成NoSuchMethodError、NoSuchFieldError等错误信息。

**3.**  **初始化**

​    初始化过程即为执行类中的静态初始化代码、构造器代码以及静态属性的初始化，在四种情况下初始化过程会被触发执行：



调用了new；

反射调用了类中的方法；

子类调用了初始化；

JVM启动过程中指定的初始化类。



**JVM装载顺序**  双亲委派机制



## 4. JVM运行时数据区

![](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1584719576971&di=9997ad3c7c42e41b8a631d8a875b96d2&imgtype=0&src=http%3A%2F%2Fimg3.itboth.com%2F56%2F23%2F6NZvMn.png)



**第一块：PC寄存器**

PC寄存器是用于存储每个线程下一步将执行的JVM指令，如该方法为native的，则PC寄存器中不存储任何信息。

**第二块：JVM**栈

JVM栈是线程私有的，每个线程创建的同时都会创建JVM栈，JVM栈中存放的为当前线程中局部基本类型的变量（java中定义的八种基本类型：boolean、char、byte、short、int、long、float、double）、部分的返回结果以及Stack Frame，非基本类型的对象在JVM栈上仅存放一个指向堆上的地址

**第三块：堆（Heap）**

它是JVM用来存储对象实例以及数组值的区域，可以认为Java中所有通过new创建的对象的内存都在此分配，Heap中的对象的内存需要等待GC进行回收。

   （1）堆是JVM中所有线程共享的，因此在其上进行对象内存的分配均需要进行加锁，这也导致了new对象的开销是比较大的

   （2）Sun Hotspot JVM为了提升对象内存分配的效率，对于所创建的线程都会分配一块独立的空间TLAB（Thread Local Allocation Buffer），其大小由JVM根据运行的情况计算而得，在TLAB上分配对象时不需要加锁，因此JVM在给线程的对象分配内存时会尽量的在TLAB上分配，在这种情况下JVM中分配对象内存的性能和C基本是一样高效的，但如果对象过大的话则仍然是直接使用堆空间分配

   （3）TLAB仅作用于新生代的Eden Space，因此在编写Java程序时，通常多个小的对象比大的对象分配起来更加高效。

**第四块：方法区域（Method Area**）

   （1）在Sun JDK中这块区域对应的为PermanetGeneration，又称为持久代。

   （2）方法区域存放了所加载的类的信息（名称、修饰符等）、类中的静态变量、类中定义为final类型的常量、类中的Field信息、类中的方法信息，当开发人员在程序中通过Class

对象中的getName、isInterface等方法来获取信息时，这些数据都来源于方法区域，同时方法区域也是全局共享的，在一定的条件下它也会被GC，当方法区域需要使用的内存超过其允许的大小时，会抛出OutOfMemory的错误信息。

**第五块：运行时常量池（Runtime Constant Pool**）

​    存放的为类中的固定的常量信息、方法和Field的引用信息等，其空间从方法区域中分配。

**第六块：本地方法堆栈（Native Method Stacks**

​    JVM采用本地方法堆栈来支持native方法的执行，此区域用于存储每个native方法调用的状态。





## GC

#### 轻GC

#### 重GC

#### GC算法

1. 复制算法
2. 标记清除算法
3. 标记压缩算法







